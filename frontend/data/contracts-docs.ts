export const contractDescriptions = [
  {
    name: 'ZKToken.sol',
    color: 'violet' as const,
    description:
      'The main contract. ERC-1400 security token with transferWithProof(). Manages balances, partitions, nullifiers, and legal documents.',
    features: [
      'Calls UltraVerifier for ZK verification',
      'Reads the root from Registry',
      'Stores used nullifiers (anti-replay)',
      'Supports freeze/unfreeze by the regulator',
    ],
  },
  {
    name: 'Registry.sol',
    color: 'emerald' as const,
    description:
      'Stores the Merkle root — the link between the off-chain world (investor tree) and the on-chain world. Only the bank can update it.',
    features: [
      'updateRoot(bytes32) — bank only',
      'getCurrentRoot() — read by ZKToken',
      'isValidRoot() — grace period (last 100 roots)',
      'Separable: reusable by multiple tokens',
    ],
  },
];

export const transferWithProofCode = `function transferWithProof(
    address to,
    uint256 amount,
    bytes calldata proof,
    bytes32[] calldata publicInputs
) external {
    // 0. Account not frozen by regulator
    require(!frozen[msg.sender], "Account frozen");

    // 1. Valid Merkle root (~2k gas)
    require(
        bytes32(publicInputs[0]) == registry.getCurrentRoot(),
        "Invalid merkle root"
    );

    // 2. Nullifier — anti-replay (~5k gas)
    bytes32 nullifier = bytes32(publicInputs[1]);
    require(!usedNullifiers[nullifier], "Proof already used");
    usedNullifiers[nullifier] = true;

    // 3. Recipient binding (~500 gas)
    require(
        uint256(publicInputs[2]) == uint256(uint160(to)),
        "Recipient mismatch"
    );

    // 4. Sender binding (~500 gas)
    require(
        uint256(publicInputs[3]) == uint256(uint160(msg.sender)),
        "Sender mismatch"
    );

    // 5. Amount binding (~500 gas)
    require(uint256(publicInputs[4]) == amount, "Amount mismatch");

    // 6. ZK PROOF VERIFICATION (~300k gas)
    require(verifier.verify(proof, publicInputs), "Invalid ZK proof");

    // 7. ERC-20 Transfer (~10k gas)
    require(balanceOf[msg.sender] >= amount, "Insufficient");
    balanceOf[msg.sender] -= amount;
    balanceOf[to] += amount;

    emit Transfer(msg.sender, to, amount);
}`;

export const deploymentSteps = [
  {
    step: '01',
    title: 'UltraVerifier',
    description: 'Generated by nargo codegen-verifier. No dependencies.',
    tech: 'forge create',
    actor: 'Contract' as const,
  },
  {
    step: '02',
    title: 'Registry',
    description: 'Constructor: bank address.',
    tech: 'forge create',
    actor: 'Contract' as const,
  },
  {
    step: '03',
    title: 'ZKToken',
    description: 'Constructor: verifier + registry + issuer addresses.',
    tech: 'forge create',
    actor: 'Contract' as const,
  },
  {
    step: '04',
    title: 'Update root',
    description: 'The bank publishes the first Merkle root.',
    tech: 'cast send',
    actor: 'Bank' as const,
  },
  {
    step: '05',
    title: 'Mint',
    description: 'The issuer mints security tokens to investors.',
    tech: 'cast send',
    actor: 'Bank' as const,
  },
];

export const contractsCallout = {
  type: 'success' as const,
  title: 'Gas optimization',
  text: 'Cheap require() checks (~8k gas total) run before verifier.verify() (~300k gas). If any check fails, the transaction reverts before paying for verification — saving 97% of gas on errors.',
};
