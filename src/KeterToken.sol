// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {UltraVerifier} from "./UltraVerifier.sol";
import {Registry} from "./Registry.sol";

/**
 * @title KeterToken — Full ERC-1400 Security Token with ZK Compliance
 * @notice Implements ERC-1410 (Partitions) + ERC-1594 (Core) + ERC-1643 (Documents) + ERC-1644 (Controller)
 *         with privacy-preserving compliance via Zero-Knowledge Proofs (Noir/UltraPlonk).
 * @dev Replaces the old ZKToken.sol. All transfers require a valid ZK proof
 *      attesting membership in the off-chain Merkle tree managed by the issuer.
 *
 * Architecture:
 *   KeterToken ──reads──► Registry.sol   (Merkle root storage)
 *   KeterToken ──calls──► UltraVerifier.sol (ZK proof verification, auto-generated by Noir)
 *
 * On-chain footprint: only the 32-byte Merkle root is public.
 * No identity data, no whitelist, no KYC attributes are ever stored or revealed on-chain.
 */
contract KeterToken {

    // ═══════════════════════════════════════════════════════════════════
    //  CONSTANTS
    // ═══════════════════════════════════════════════════════════════════

    /// @dev Status codes (ERC-1066 subset) returned by canTransfer / canTransferByPartition
    bytes1 public constant STATUS_TRANSFER_FAILURE    = 0x50;
    bytes1 public constant STATUS_TRANSFER_SUCCESS    = 0x51;
    bytes1 public constant STATUS_INSUFFICIENT_BALANCE = 0x52;
    bytes1 public constant STATUS_TRANSFERS_HALTED    = 0x54;
    bytes1 public constant STATUS_FUNDS_LOCKED        = 0x55;
    bytes1 public constant STATUS_INVALID_SENDER      = 0x56;
    bytes1 public constant STATUS_INVALID_RECEIVER    = 0x57;
    bytes1 public constant STATUS_INVALID_OPERATOR    = 0x58;

    /// @dev Default partition used for plain ERC-20 transfers
    bytes32 public constant DEFAULT_PARTITION = bytes32(0);

    // ═══════════════════════════════════════════════════════════════════
    //  ERC-20 METADATA
    // ═══════════════════════════════════════════════════════════════════

    string public name;
    string public symbol;
    uint8  public constant decimals = 18;
    uint256 public totalSupply;

    // ═══════════════════════════════════════════════════════════════════
    //  ROLES
    // ═══════════════════════════════════════════════════════════════════

    address public issuer;                          // deployer, can mint/configure
    address[] public controllers;                   // can force-transfer (regulator, transfer agent)
    mapping(address => bool) public isController;

    // ═══════════════════════════════════════════════════════════════════
    //  TOKEN STATE FLAGS
    // ═══════════════════════════════════════════════════════════════════

    bool public isIssuable_     = true;   // can new tokens be minted?
    bool public isControllable_ = true;   // can controllers force-transfer?
    bool public paused;                   // emergency stop

    // ═══════════════════════════════════════════════════════════════════
    //  EXTERNAL CONTRACTS
    // ═══════════════════════════════════════════════════════════════════

    Registry       public registry;
    UltraVerifier  public verifier;

    // ═══════════════════════════════════════════════════════════════════
    //  ERC-1410: PARTITIONS
    // ═══════════════════════════════════════════════════════════════════

    /// @dev partition → holder → balance
    mapping(bytes32 => mapping(address => uint256)) internal _balancesByPartition;

    /// @dev holder → list of partitions they hold tokens in
    mapping(address => bytes32[]) internal _partitionsOf;

    /// @dev holder → partition → whether it's already in their _partitionsOf array
    mapping(address => mapping(bytes32 => bool)) internal _partitionExists;

    /// @dev Total supply per partition
    mapping(bytes32 => uint256) public totalSupplyByPartition;

    /// @dev Ordered list of default partitions for ERC-20 fallback
    bytes32[] public defaultPartitions;

    /// @dev partition → operator → holder → authorized
    mapping(bytes32 => mapping(address => mapping(address => bool))) internal _authorizedOperatorByPartition;

    /// @dev holder → operator → authorized (all partitions)
    mapping(address => mapping(address => bool)) internal _authorizedOperator;

    // ═══════════════════════════════════════════════════════════════════
    //  ERC-20 COMPATIBILITY
    // ═══════════════════════════════════════════════════════════════════

    /// @dev ERC-20 allowances (for DEX/approval patterns)
    mapping(address => mapping(address => uint256)) internal _allowances;

    // ═══════════════════════════════════════════════════════════════════
    //  ERC-1643: DOCUMENTS
    // ═══════════════════════════════════════════════════════════════════

    struct Document {
        string  uri;
        bytes32 docHash;
        uint256 timestamp;
    }

    mapping(bytes32 => Document) internal _documents;
    bytes32[] internal _documentNames;
    mapping(bytes32 => bool) internal _documentExists;

    // ═══════════════════════════════════════════════════════════════════
    //  ZK: NULLIFIERS (anti-replay)
    // ═══════════════════════════════════════════════════════════════════

    mapping(bytes32 => bool) public usedNullifiers;

    // ═══════════════════════════════════════════════════════════════════
    //  EVENTS — ERC-20
    // ═══════════════════════════════════════════════════════════════════

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    // ═══════════════════════════════════════════════════════════════════
    //  EVENTS — ERC-1410 (Partitions)
    // ═══════════════════════════════════════════════════════════════════

    event TransferByPartition(
        bytes32 indexed fromPartition,
        address         operator,
        address indexed from,
        address indexed to,
        uint256         value,
        bytes           data,
        bytes           operatorData
    );

    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);
    event RevokedOperator(address indexed operator, address indexed tokenHolder);
    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);
    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);

    // ═══════════════════════════════════════════════════════════════════
    //  EVENTS — ERC-1594 (Core)
    // ═══════════════════════════════════════════════════════════════════

    event Issued(address indexed operator, address indexed to, uint256 value, bytes data);
    event Redeemed(address indexed operator, address indexed from, uint256 value, bytes data);
    event IssuedByPartition(bytes32 indexed partition, address indexed to, uint256 value, bytes data);
    event RedeemedByPartition(bytes32 indexed partition, address indexed from, uint256 value, bytes data);

    // ═══════════════════════════════════════════════════════════════════
    //  EVENTS — ERC-1643 (Documents)
    // ═══════════════════════════════════════════════════════════════════

    event DocumentUpdated(bytes32 indexed docName, string uri, bytes32 documentHash);
    event DocumentRemoved(bytes32 indexed docName, string uri, bytes32 documentHash);

    // ═══════════════════════════════════════════════════════════════════
    //  EVENTS — ERC-1644 (Controller)
    // ═══════════════════════════════════════════════════════════════════

    event ControllerTransfer(
        address         controller,
        address indexed from,
        address indexed to,
        uint256         value,
        bytes           data,
        bytes           operatorData
    );

    event ControllerRedemption(
        address         controller,
        address indexed tokenHolder,
        uint256         value,
        bytes           data,
        bytes           operatorData
    );

    // ═══════════════════════════════════════════════════════════════════
    //  EVENTS — KETER ZK
    // ═══════════════════════════════════════════════════════════════════

    event ProofVerified(address indexed sender, bytes32 merkleRoot, bytes32 nullifier, uint256 timestamp);
    event ComplianceTransfer(
        address indexed from,
        address indexed to,
        uint256         amount,
        bytes32         proofHash,
        bytes32 indexed partition
    );

    // ═══════════════════════════════════════════════════════════════════
    //  MODIFIERS
    // ═══════════════════════════════════════════════════════════════════

    modifier onlyIssuer() {
        require(msg.sender == issuer, "KT: not issuer");
        _;
    }

    modifier onlyControllerOrIssuer() {
        require(msg.sender == issuer || isController[msg.sender], "KT: not controller");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, "KT: paused");
        _;
    }

    modifier whenIssuable() {
        require(isIssuable_, "KT: issuance closed");
        _;
    }

    // ═══════════════════════════════════════════════════════════════════
    //  CONSTRUCTOR
    // ═══════════════════════════════════════════════════════════════════

    /**
     * @param _name           Token name (e.g. "Keter Security Token")
     * @param _symbol         Token symbol (e.g. "KETER")
     * @param _registry       Address of deployed Registry.sol
     * @param _verifier       Address of deployed UltraVerifier.sol
     * @param _controllers    Initial controller addresses (regulator, transfer agent)
     * @param _defaultParts   Default partitions for ERC-20 fallback
     */
    constructor(
        string memory   _name,
        string memory   _symbol,
        address         _registry,
        address         _verifier,
        address[] memory _controllers,
        bytes32[] memory _defaultParts
    ) {
        name     = _name;
        symbol   = _symbol;
        issuer   = msg.sender;
        registry = Registry(_registry);
        verifier = UltraVerifier(_verifier);

        // Register controllers
        for (uint256 i = 0; i < _controllers.length; i++) {
            controllers.push(_controllers[i]);
            isController[_controllers[i]] = true;
        }

        // Set default partitions (at minimum, the DEFAULT_PARTITION)
        if (_defaultParts.length == 0) {
            defaultPartitions.push(DEFAULT_PARTITION);
        } else {
            for (uint256 i = 0; i < _defaultParts.length; i++) {
                defaultPartitions.push(_defaultParts[i]);
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    //  ERC-20 — BASIC INTERFACE
    // ═══════════════════════════════════════════════════════════════════

    /// @notice Total balance across ALL partitions
    function balanceOf(address _holder) public view returns (uint256 total) {
        bytes32[] memory parts = _partitionsOf[_holder];
        for (uint256 i = 0; i < parts.length; i++) {
            total += _balancesByPartition[parts[i]][_holder];
        }
    }

    /// @notice ERC-20 transfer — pulls from default partitions in order
    function transfer(address _to, uint256 _value) external whenNotPaused returns (bool) {
        _transferFromDefaultPartitions(msg.sender, _to, _value, "");
        return true;
    }

    /// @notice ERC-20 transferFrom — pulls from default partitions in order
    function transferFrom(address _from, address _to, uint256 _value) external whenNotPaused returns (bool) {
        require(_allowances[_from][msg.sender] >= _value, "KT: insufficient allowance");
        _allowances[_from][msg.sender] -= _value;
        _transferFromDefaultPartitions(_from, _to, _value, "");
        return true;
    }

    function approve(address _spender, uint256 _value) external returns (bool) {
        _allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) external view returns (uint256) {
        return _allowances[_owner][_spender];
    }

    // ═══════════════════════════════════════════════════════════════════
    //  ERC-1410 — PARTIALLY FUNGIBLE TOKENS (PARTITIONS)
    // ═══════════════════════════════════════════════════════════════════

    /// @notice Balance for a specific partition
    function balanceOfByPartition(bytes32 _partition, address _holder) public view returns (uint256) {
        return _balancesByPartition[_partition][_holder];
    }

    /// @notice All partitions a holder has tokens in
    function partitionsOf(address _holder) external view returns (bytes32[] memory) {
        return _partitionsOf[_holder];
    }

    /// @notice Transfer tokens from a specific partition (NO ZK proof — only between verified parties)
    /// @dev For ZK-verified transfers, use transferByPartitionWithProof
    function transferByPartition(
        bytes32 _partition,
        address _to,
        uint256 _value,
        bytes calldata _data
    ) external whenNotPaused returns (bytes32) {
        _transferByPartition(_partition, msg.sender, _to, _value, _data, "");
        return _partition;
    }

    /// @notice Operator transfer from a specific partition
    function operatorTransferByPartition(
        bytes32 _partition,
        address _from,
        address _to,
        uint256 _value,
        bytes calldata _data,
        bytes calldata _operatorData
    ) external whenNotPaused returns (bytes32) {
        require(
            _isOperatorForPartition(_partition, msg.sender, _from) ||
            (isControllable_ && (msg.sender == issuer || isController[msg.sender])),
            "KT: not authorized operator"
        );

        _transferByPartition(_partition, _from, _to, _value, _data, _operatorData);

        // Emit controller event if this is a forced transfer
        if (isControllable_ && (msg.sender == issuer || isController[msg.sender])) {
            if (!_authorizedOperatorByPartition[_partition][msg.sender][_from] &&
                !_authorizedOperator[_from][msg.sender]) {
                emit ControllerTransfer(msg.sender, _from, _to, _value, _data, _operatorData);
            }
        }

        return _partition;
    }

    // ── Operator management ──

    function authorizeOperator(address _operator) external {
        _authorizedOperator[msg.sender][_operator] = true;
        emit AuthorizedOperator(_operator, msg.sender);
    }

    function revokeOperator(address _operator) external {
        _authorizedOperator[msg.sender][_operator] = false;
        emit RevokedOperator(_operator, msg.sender);
    }

    function authorizeOperatorByPartition(bytes32 _partition, address _operator) external {
        _authorizedOperatorByPartition[_partition][_operator][msg.sender] = true;
        emit AuthorizedOperatorByPartition(_partition, _operator, msg.sender);
    }

    function revokeOperatorByPartition(bytes32 _partition, address _operator) external {
        _authorizedOperatorByPartition[_partition][_operator][msg.sender] = false;
        emit RevokedOperatorByPartition(_partition, _operator, msg.sender);
    }

    function isOperatorForPartition(bytes32 _partition, address _operator, address _holder) external view returns (bool) {
        return _isOperatorForPartition(_partition, _operator, _holder);
    }

    // ═══════════════════════════════════════════════════════════════════
    //  ERC-1594 — CORE SECURITY TOKEN
    // ═══════════════════════════════════════════════════════════════════

    function isIssuable() external view returns (bool) {
        return isIssuable_;
    }

    function isControllable() external view returns (bool) {
        return isControllable_;
    }

    /// @notice Check if a transfer would succeed (ERC-1066 status code)
    function canTransfer(address _to, uint256 _value, bytes calldata)
        external view returns (bytes1 statusCode, bytes32 reasonCode)
    {
        if (paused) return (STATUS_TRANSFERS_HALTED, bytes32("paused"));
        if (_to == address(0)) return (STATUS_INVALID_RECEIVER, bytes32("zero address"));
        if (balanceOf(msg.sender) < _value) return (STATUS_INSUFFICIENT_BALANCE, bytes32("balance"));
        return (STATUS_TRANSFER_SUCCESS, bytes32(0));
    }

    /// @notice Check if a partition transfer would succeed
    function canTransferByPartition(
        bytes32 _partition,
        address _to,
        uint256 _value,
        bytes calldata
    ) external view returns (bytes1 statusCode, bytes32 reasonCode, bytes32 partition) {
        if (paused) return (STATUS_TRANSFERS_HALTED, bytes32("paused"), _partition);
        if (_to == address(0)) return (STATUS_INVALID_RECEIVER, bytes32("zero address"), _partition);
        if (_balancesByPartition[_partition][msg.sender] < _value)
            return (STATUS_INSUFFICIENT_BALANCE, bytes32("balance"), _partition);
        return (STATUS_TRANSFER_SUCCESS, bytes32(0), _partition);
    }

    /// @notice Transfer with off-chain data injection (ERC-1594)
    function transferWithData(address _to, uint256 _value, bytes calldata _data) external whenNotPaused {
        _transferFromDefaultPartitions(msg.sender, _to, _value, _data);
    }

    function transferFromWithData(address _from, address _to, uint256 _value, bytes calldata _data) external whenNotPaused {
        require(
            _allowances[_from][msg.sender] >= _value || _authorizedOperator[_from][msg.sender],
            "KT: not authorized"
        );
        if (_allowances[_from][msg.sender] >= _value) {
            _allowances[_from][msg.sender] -= _value;
        }
        _transferFromDefaultPartitions(_from, _to, _value, _data);
    }

    // ── Issuance ──

    /// @notice Issue tokens to the default partition
    function issue(address _to, uint256 _value, bytes calldata _data) external onlyIssuer whenIssuable {
        _issueByPartition(defaultPartitions[0], _to, _value, _data);
        emit Issued(msg.sender, _to, _value, _data);
    }

    /// @notice Issue tokens to a specific partition
    function issueByPartition(bytes32 _partition, address _to, uint256 _value, bytes calldata _data)
        external onlyIssuer whenIssuable
    {
        _issueByPartition(_partition, _to, _value, _data);
    }

    // ── Redemption ──

    /// @notice Holder redeems (burns) their own tokens from default partitions
    function redeem(uint256 _value, bytes calldata _data) external whenNotPaused {
        _redeemFromDefaultPartitions(msg.sender, _value, _data);
        emit Redeemed(msg.sender, msg.sender, _value, _data);
    }

    /// @notice Holder redeems from a specific partition
    function redeemByPartition(bytes32 _partition, uint256 _value, bytes calldata _data) external whenNotPaused {
        _redeemByPartition(_partition, msg.sender, _value, _data);
    }

    /// @notice Operator redeems on behalf of holder from a specific partition
    function operatorRedeemByPartition(
        bytes32 _partition,
        address _tokenHolder,
        uint256 _value,
        bytes calldata _operatorData
    ) external whenNotPaused {
        require(
            _isOperatorForPartition(_partition, msg.sender, _tokenHolder) ||
            (isControllable_ && (msg.sender == issuer || isController[msg.sender])),
            "KT: not authorized"
        );
        _redeemByPartition(_partition, _tokenHolder, _value, _operatorData);

        if (isControllable_ && (msg.sender == issuer || isController[msg.sender])) {
            emit ControllerRedemption(msg.sender, _tokenHolder, _value, _operatorData, "");
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    //  ERC-1643 — DOCUMENT MANAGEMENT
    // ═══════════════════════════════════════════════════════════════════

    function getDocument(bytes32 _name)
        external view returns (string memory uri, bytes32 docHash, uint256 timestamp)
    {
        Document storage doc = _documents[_name];
        return (doc.uri, doc.docHash, doc.timestamp);
    }

    function setDocument(bytes32 _name, string calldata _uri, bytes32 _docHash) external onlyIssuer {
        if (!_documentExists[_name]) {
            _documentNames.push(_name);
            _documentExists[_name] = true;
        }
        _documents[_name] = Document(_uri, _docHash, block.timestamp);
        emit DocumentUpdated(_name, _uri, _docHash);
    }

    function removeDocument(bytes32 _name) external onlyIssuer {
        require(_documentExists[_name], "KT: doc not found");
        Document storage doc = _documents[_name];
        emit DocumentRemoved(_name, doc.uri, doc.docHash);

        delete _documents[_name];
        _documentExists[_name] = false;

        // Remove from array (swap & pop)
        for (uint256 i = 0; i < _documentNames.length; i++) {
            if (_documentNames[i] == _name) {
                _documentNames[i] = _documentNames[_documentNames.length - 1];
                _documentNames.pop();
                break;
            }
        }
    }

    function getAllDocuments() external view returns (bytes32[] memory) {
        return _documentNames;
    }

    // ═══════════════════════════════════════════════════════════════════
    //  ERC-1644 — CONTROLLER OPERATIONS (FORCE TRANSFER)
    // ═══════════════════════════════════════════════════════════════════

    /// @notice Force transfer tokens between addresses (e.g. court order, fraud recovery)
    /// @dev NO ZK proof required — controller is a trusted authority
    function controllerTransfer(
        address _from,
        address _to,
        uint256 _value,
        bytes calldata _data,
        bytes calldata _operatorData
    ) external onlyControllerOrIssuer {
        require(isControllable_, "KT: not controllable");
        _transferFromDefaultPartitions(_from, _to, _value, _data);
        emit ControllerTransfer(msg.sender, _from, _to, _value, _data, _operatorData);
    }

    /// @notice Force transfer from a specific partition
    function controllerTransferByPartition(
        bytes32 _partition,
        address _from,
        address _to,
        uint256 _value,
        bytes calldata _data,
        bytes calldata _operatorData
    ) external onlyControllerOrIssuer {
        require(isControllable_, "KT: not controllable");
        _transferByPartition(_partition, _from, _to, _value, _data, _operatorData);
        emit ControllerTransfer(msg.sender, _from, _to, _value, _data, _operatorData);
    }

    /// @notice Force redeem (burn) tokens
    function controllerRedeem(
        address _tokenHolder,
        uint256 _value,
        bytes calldata _data,
        bytes calldata _operatorData
    ) external onlyControllerOrIssuer {
        require(isControllable_, "KT: not controllable");
        _redeemFromDefaultPartitions(_tokenHolder, _value, _data);
        emit ControllerRedemption(msg.sender, _tokenHolder, _value, _data, _operatorData);
    }

    // ═══════════════════════════════════════════════════════════════════
    //  KETER ZK — TRANSFER WITH PROOF
    // ═══════════════════════════════════════════════════════════════════

    /**
     * @notice Transfer tokens from default partition with ZK compliance proof.
     * @param _to             Recipient address
     * @param _value          Amount to transfer
     * @param _proof          ZK proof bytes (UltraPlonk, generated by Noir)
     * @param _publicInputs   Public inputs: [0] = merkle_root, [1] = nullifier (optional)
     */
    function transferWithProof(
        address _to,
        uint256 _value,
        bytes calldata _proof,
        bytes32[] calldata _publicInputs
    ) external whenNotPaused {
        _verifyProof(_proof, _publicInputs);
        _transferFromDefaultPartitions(msg.sender, _to, _value, "");

        emit ComplianceTransfer(msg.sender, _to, _value, keccak256(_proof), defaultPartitions[0]);
    }

    /**
     * @notice Transfer tokens from a SPECIFIC partition with ZK compliance proof.
     * @param _partition      Source partition
     * @param _to             Recipient address
     * @param _value          Amount to transfer
     * @param _proof          ZK proof bytes
     * @param _publicInputs   Public inputs: [0] = merkle_root, [1] = nullifier (optional)
     */
    function transferByPartitionWithProof(
        bytes32 _partition,
        address _to,
        uint256 _value,
        bytes calldata _proof,
        bytes32[] calldata _publicInputs
    ) external whenNotPaused {
        _verifyProof(_proof, _publicInputs);
        _transferByPartition(_partition, msg.sender, _to, _value, "", "");

        emit ComplianceTransfer(msg.sender, _to, _value, keccak256(_proof), _partition);
    }

    /**
     * @notice Dual proof transfer — both sender AND receiver prove compliance
     * @dev v2 feature: prevents tokens from landing in non-compliant wallets
     */
    function transferWithDualProof(
        address _to,
        uint256 _value,
        bytes calldata _senderProof,
        bytes32[] calldata _senderPublicInputs,
        bytes calldata _receiverProof,
        bytes32[] calldata _receiverPublicInputs
    ) external whenNotPaused {
        _verifyProof(_senderProof, _senderPublicInputs);
        _verifyProof(_receiverProof, _receiverPublicInputs);
        _transferFromDefaultPartitions(msg.sender, _to, _value, "");

        emit ComplianceTransfer(msg.sender, _to, _value, keccak256(_senderProof), defaultPartitions[0]);
    }

    /**
     * @notice Dual proof transfer from a specific partition
     */
    function transferByPartitionWithDualProof(
        bytes32 _partition,
        address _to,
        uint256 _value,
        bytes calldata _senderProof,
        bytes32[] calldata _senderPublicInputs,
        bytes calldata _receiverProof,
        bytes32[] calldata _receiverPublicInputs
    ) external whenNotPaused {
        _verifyProof(_senderProof, _senderPublicInputs);
        _verifyProof(_receiverProof, _receiverPublicInputs);
        _transferByPartition(_partition, msg.sender, _to, _value, "", "");

        emit ComplianceTransfer(msg.sender, _to, _value, keccak256(_senderProof), _partition);
    }

    // ═══════════════════════════════════════════════════════════════════
    //  ADMIN FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════

    /// @notice Permanently disable future issuance (IRREVERSIBLE)
    function finalizeIssuance() external onlyIssuer {
        isIssuable_ = false;
    }

    /// @notice Permanently disable controller powers (IRREVERSIBLE)
    function renounceControl() external onlyIssuer {
        isControllable_ = false;
    }

    /// @notice Emergency pause — halts all transfers
    function pause() external onlyControllerOrIssuer {
        paused = true;
    }

    /// @notice Unpause transfers
    function unpause() external onlyControllerOrIssuer {
        paused = false;
    }

    /// @notice Add a controller
    function addController(address _controller) external onlyIssuer {
        require(!isController[_controller], "KT: already controller");
        controllers.push(_controller);
        isController[_controller] = true;
    }

    /// @notice Remove a controller
    function removeController(address _controller) external onlyIssuer {
        require(isController[_controller], "KT: not controller");
        isController[_controller] = false;
        for (uint256 i = 0; i < controllers.length; i++) {
            if (controllers[i] == _controller) {
                controllers[i] = controllers[controllers.length - 1];
                controllers.pop();
                break;
            }
        }
    }

    /// @notice Update registry address
    function setRegistry(address _registry) external onlyIssuer {
        registry = Registry(_registry);
    }

    /// @notice Update verifier address
    function setVerifier(address _verifier) external onlyIssuer {
        verifier = UltraVerifier(_verifier);
    }

    /// @notice Set default partitions
    function setDefaultPartitions(bytes32[] calldata _partitions) external onlyIssuer {
        delete defaultPartitions;
        for (uint256 i = 0; i < _partitions.length; i++) {
            defaultPartitions.push(_partitions[i]);
        }
    }

    /// @notice Check if an address is the issuer
    function isIssuer(address _addr) external view returns (bool) {
        return _addr == issuer;
    }

    /// @notice Get all controllers
    function getControllers() external view returns (address[] memory) {
        return controllers;
    }

    /// @notice Get all default partitions
    function getDefaultPartitions() external view returns (bytes32[] memory) {
        return defaultPartitions;
    }

    // ═══════════════════════════════════════════════════════════════════
    //  INTERNAL — ZK PROOF VERIFICATION
    // ═══════════════════════════════════════════════════════════════════

    /**
     * @dev Verify a ZK proof against the Registry's Merkle root.
     *      Supports optional nullifier in publicInputs[1].
     */
    function _verifyProof(bytes calldata _proof, bytes32[] calldata _publicInputs) internal {
        require(_publicInputs.length >= 1, "KT: missing public inputs");

        // 1. Check Merkle root matches Registry
        require(
            _publicInputs[0] == registry.getMerkleRoot(),
            "KT: root mismatch"
        );

        // 2. If nullifier provided, check it hasn't been used (anti-replay)
        if (_publicInputs.length >= 2) {
            bytes32 nullifier = _publicInputs[1];
            require(!usedNullifiers[nullifier], "KT: proof already used");
            usedNullifiers[nullifier] = true;
        }

        // 3. Verify the ZK proof via UltraVerifier
        require(
            verifier.verify(_proof, _publicInputs),
            "KT: invalid proof"
        );

        emit ProofVerified(msg.sender, _publicInputs[0],
            _publicInputs.length >= 2 ? _publicInputs[1] : bytes32(0),
            block.timestamp
        );
    }

    // ═══════════════════════════════════════════════════════════════════
    //  INTERNAL — PARTITION TRANSFER LOGIC
    // ═══════════════════════════════════════════════════════════════════

    /**
     * @dev Core partition transfer. Updates both partition balances and emits events.
     */
    function _transferByPartition(
        bytes32 _partition,
        address _from,
        address _to,
        uint256 _value,
        bytes memory _data,
        bytes memory _operatorData
    ) internal {
        require(_to != address(0), "KT: transfer to zero");
        require(_balancesByPartition[_partition][_from] >= _value, "KT: insufficient partition balance");

        _balancesByPartition[_partition][_from] -= _value;
        _removePartitionIfEmpty(_partition, _from);

        _addToPartition(_partition, _to, _value);

        emit TransferByPartition(_partition, msg.sender, _from, _to, _value, _data, _operatorData);
        emit Transfer(_from, _to, _value);
    }

    /**
     * @dev Transfer from default partitions in order (ERC-20 fallback).
     *      Drains partitions sequentially until the full amount is covered.
     */
    function _transferFromDefaultPartitions(
        address _from,
        address _to,
        uint256 _value,
        bytes memory _data
    ) internal {
        require(_to != address(0), "KT: transfer to zero");
        uint256 remaining = _value;

        for (uint256 i = 0; i < defaultPartitions.length && remaining > 0; i++) {
            bytes32 part = defaultPartitions[i];
            uint256 partBalance = _balancesByPartition[part][_from];

            if (partBalance > 0) {
                uint256 amount = partBalance >= remaining ? remaining : partBalance;
                _transferByPartition(part, _from, _to, amount, _data, "");
                remaining -= amount;
            }
        }

        require(remaining == 0, "KT: insufficient balance across default partitions");
    }

    // ═══════════════════════════════════════════════════════════════════
    //  INTERNAL — ISSUANCE & REDEMPTION
    // ═══════════════════════════════════════════════════════════════════

    function _issueByPartition(bytes32 _partition, address _to, uint256 _value, bytes memory _data) internal {
        require(_to != address(0), "KT: issue to zero");

        totalSupply += _value;
        totalSupplyByPartition[_partition] += _value;
        _addToPartition(_partition, _to, _value);

        emit IssuedByPartition(_partition, _to, _value, _data);
        emit Transfer(address(0), _to, _value);
    }

    function _redeemByPartition(bytes32 _partition, address _holder, uint256 _value, bytes memory _data) internal {
        require(_balancesByPartition[_partition][_holder] >= _value, "KT: insufficient partition balance");

        _balancesByPartition[_partition][_holder] -= _value;
        _removePartitionIfEmpty(_partition, _holder);

        totalSupply -= _value;
        totalSupplyByPartition[_partition] -= _value;

        emit RedeemedByPartition(_partition, _holder, _value, _data);
        emit Transfer(_holder, address(0), _value);
    }

    function _redeemFromDefaultPartitions(address _holder, uint256 _value, bytes memory _data) internal {
        uint256 remaining = _value;

        for (uint256 i = 0; i < defaultPartitions.length && remaining > 0; i++) {
            bytes32 part = defaultPartitions[i];
            uint256 partBalance = _balancesByPartition[part][_holder];

            if (partBalance > 0) {
                uint256 amount = partBalance >= remaining ? remaining : partBalance;
                _redeemByPartition(part, _holder, amount, _data);
                remaining -= amount;
            }
        }

        require(remaining == 0, "KT: insufficient balance across default partitions");
    }

    // ═══════════════════════════════════════════════════════════════════
    //  INTERNAL — PARTITION HELPERS
    // ═══════════════════════════════════════════════════════════════════

    function _addToPartition(bytes32 _partition, address _holder, uint256 _value) internal {
        if (!_partitionExists[_holder][_partition]) {
            _partitionsOf[_holder].push(_partition);
            _partitionExists[_holder][_partition] = true;
        }
        _balancesByPartition[_partition][_holder] += _value;
    }

    function _removePartitionIfEmpty(bytes32 _partition, address _holder) internal {
        if (_balancesByPartition[_partition][_holder] == 0 && _partitionExists[_holder][_partition]) {
            _partitionExists[_holder][_partition] = false;
            bytes32[] storage parts = _partitionsOf[_holder];
            for (uint256 i = 0; i < parts.length; i++) {
                if (parts[i] == _partition) {
                    parts[i] = parts[parts.length - 1];
                    parts.pop();
                    break;
                }
            }
        }
    }

    function _isOperatorForPartition(bytes32 _partition, address _operator, address _holder)
        internal view returns (bool)
    {
        return _authorizedOperatorByPartition[_partition][_operator][_holder] ||
               _authorizedOperator[_holder][_operator] ||
               _operator == _holder;
    }
}
